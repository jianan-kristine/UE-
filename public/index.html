<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CompLens - AI Competitive Analysis</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="language-selector">
        <button class="lang-btn active" data-lang="zh">ä¸­æ–‡</button>
        <button class="lang-btn" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="ja">æ—¥æœ¬èª</button>
      </div>
      <div class="header-subtitle" data-i18n="headerSubtitle">AI COMPETITIVE ANALYSIS</div>
      <h1 data-i18n="headerTitle">å‘ç°å¡‘é€ ä½ ç«äº‰ä¼˜åŠ¿çš„<em>æ´å¯Ÿ</em></h1>
    </div>

    <div class="content">
      <div class="input-section" id="inputSection">
        <label for="ideaInput" data-i18n="inputLabel">è¾“å…¥ä½ çš„äº§å“æƒ³æ³•</label>
        <textarea
          id="ideaInput"
          data-i18n-placeholder="inputPlaceholder"
          placeholder="ä¾‹å¦‚ï¼šä¸€ä¸ªå¸®åŠ©ç”¨æˆ·ç®¡ç†ä¸ªäººè´¢åŠ¡çš„ç§»åŠ¨åº”ç”¨ï¼ŒåŒ…å«é¢„ç®—è·Ÿè¸ªã€æŠ•èµ„å»ºè®®å’Œè‡ªåŠ¨åˆ†ç±»åŠŸèƒ½..."
        ></textarea>

        <!-- æ–‡ä»¶ä¸Šä¼  -->
        <div style="margin-top: 16px;">
          <label for="fileInput" data-i18n="fileInputLabel" style="font-size: 12px; text-transform: none; margin-bottom: 8px; color: #9ca3af;">Or upload a file (PDF, Word, TXT, MD)</label>
          <input type="file" id="fileInput" accept=".pdf,.docx,.doc,.txt,.md" multiple style="display: block; width: 100%; padding: 12px; background: #0a0e1a; color: #e5e7eb; border: 2px solid #1f2937; border-radius: 6px; font-size: 14px; cursor: pointer;" />
          <small style="color: #6b7280; font-size: 11px; margin-top: 4px; display: block;" data-i18n="fileInputHint">1 file = analyze, 2 files = compare</small>
        </div>

        <!-- persona / model / tools æ§åˆ¶ -->
        <div class="advanced-controls">
          <div class="select-group">
            <label data-i18n="personaLabel">åˆ†æè§†è§’ï¼ˆPersonaï¼‰</label>
            <!-- é€‰é¡¹ç”± JS æŒ‰è¯­è¨€åŠ¨æ€å¡«å…… -->
            <select id="personaSelect"></select>
          </div>
          <div class="select-group">
            <label data-i18n="modelLabel">æ¨¡å‹ï¼ˆModelï¼‰</label>
            <!-- é€‰é¡¹ç”± JS æŒ‰è¯­è¨€åŠ¨æ€å¡«å…… -->
            <select id="modelSelect"></select>
          </div>
          <label class="toggle-label">
            <input type="checkbox" id="webToolsToggle" checked />
            <span data-i18n="webToolsLabel">å…è®¸ä½¿ç”¨ Web æŠ“å–ï¼ˆFirecrawl ç­‰é‡å·¥å…·ï¼‰</span>
          </label>
          <label class="toggle-label">
            <input type="checkbox" id="autoContinueToggle" checked />
            <span data-i18n="autoContinueLabel">å…è®¸è‡ªåŠ¨ç»­å†™é•¿æŠ¥å‘Šï¼ˆMaxTokens è‡ªåŠ¨ç»­å†™ï¼‰</span>
          </label>
        </div>

        <!-- åˆ†ææ¨¡å¼é€‰æ‹©æŒ‰é’® -->
        <div class="button-group">
          <button type="button" class="button button-quick" id="quickBtn" data-i18n="quickBtn">
            âš¡ å¿«é€Ÿåé¦ˆ
          </button>
          <button type="button" class="button button-deep" id="deepBtn" data-i18n="deepBtn">
            ğŸ” æ·±åº¦æŸ¥æ‰¾
          </button>
        </div>

        <div class="mode-hint" id="modeHint" data-i18n="modeHint">
          <strong>å¿«é€Ÿåé¦ˆ</strong>ï¼šé™åˆ¶å·¥å…·è°ƒç”¨ï¼Œ2åˆ†é’Ÿå†…å¿«é€Ÿè¿”å›ç»“æœ<br>
          <strong>æ·±åº¦æŸ¥æ‰¾</strong>ï¼šæ— å·¥å…·é™åˆ¶ï¼Œå…¨é¢æ·±å…¥åˆ†æç«å“
        </div>

        <!-- å®¡æ‰¹å¤é€‰æ¡† -->
        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="requireToolApproval" />
            <span id="requireToolApprovalLabel">Require manual approval for Firecrawl calls</span>
          </label>
          <small class="help-text" id="requireToolApprovalHelp">When checked, AI will request your permission before calling Firecrawl tools</small>
        </div>
      </div>

      <div class="loading-section" id="loadingSection">
        <div class="spinner">
          <div></div>
          <div></div>
          <div></div>
        </div>
        <div class="loading-text" data-i18n="loadingText">æ­£åœ¨åˆ†æä¸­...</div>
        <div class="loading-subtext" data-i18n="loadingSubtext">AI æ­£åœ¨æœç´¢å’Œåˆ†æç«å“ä¿¡æ¯</div>
        
        <!-- æ˜¾ç¤ºå½“å‰åˆ†æçš„å†…å®¹ -->
        <div class="loading-query-container" id="loadingQueryContainer">
          <div class="loading-tag" id="loadingTag">é¦–æ¬¡æŸ¥è¯¢</div>
          <div class="loading-query" id="loadingQuery"></div>
        </div>
        
        <div class="progress-container">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="progress-text" id="progressText">0%</div>
        <button class="interrupt-button" id="interruptBtn" data-i18n="interruptBtn">â¸ï¸ ä¸­æ–­åˆ†æ</button>
      </div>

      <div class="error-message" id="errorMessage"></div>

      <div class="report-section" id="reportSection">
        <div class="report-header">
          <h2 data-i18n="reportTitle">åˆ†ææŠ¥å‘Š</h2>
          <div class="report-actions">
            <button class="visualize-button" id="visualizeBtn" data-i18n="visualizeBtn">
              ğŸ“Š å¯è§†åŒ–
            </button>
            <button class="back-button" id="backBtn" data-i18n="backBtn">è¿”å›</button>
          </div>
        </div>
        <div class="report-content" id="reportContent"></div>

        <!-- åŸºäºå½“å‰æŠ¥å‘Šçš„è¿½é—® -->
        <div class="followup-section">
          <label for="followUpInput" data-i18n="followUpLabel">
            åŸºäºæœ¬æ¬¡åˆ†æç»§ç»­è¿½é—®ï¼ˆä¾‹å¦‚ï¼šè¯·é‡ç‚¹æ¯”è¾ƒç¾å›½å¸‚åœºæ”¶è´¹æ¨¡å¼ / å†å±•å¼€ 2 ä¸ªå·®å¼‚æœ€å¤§çš„ç«å“ï¼‰
          </label>
          <textarea id="followUpInput" data-i18n-placeholder="followUpPlaceholder"
            placeholder="è¾“å…¥ä½ æƒ³è¿›ä¸€æ­¥æ·±æŒ–çš„é—®é¢˜æˆ–æ–¹å‘ï¼Œç„¶åç‚¹å‡»ä¸‹é¢æŒ‰é’®ç»§ç»­åˆ†æ"></textarea>
          <button class="followup-button" id="followUpBtn" data-i18n="followUpBtn">
            â• ç»§ç»­æ²¿ç€è¿™æ¡æ€è·¯åˆ†æ
          </button>
        </div>
      </div>

      <!-- å¯è§†åŒ–æ¨¡æ€æ¡† -->
      <div class="modal" id="visualModal">
        <div class="modal-content">
          <div class="modal-header">
            <h2 data-i18n="visualTitle">ğŸ“Š å¯è§†åŒ–åˆ†æ</h2>
            <button class="modal-close" id="modalClose">Ã—</button>
          </div>
          <div class="modal-body" id="visualContent"></div>
        </div>
      </div>

      <!-- Tool Approval Modal -->
      <div id="approvalModal" class="approval-modal" style="display: none;">
        <div class="approval-modal-content">
          <h3 id="approvalModalTitle">ğŸ”” å·¥å…·è°ƒç”¨å®¡æ‰¹</h3>
          <p id="approvalMessage">AI æƒ³è¦è°ƒç”¨ä»¥ä¸‹å·¥å…·ï¼š</p>
          <div class="approval-details">
            <div><strong id="approvalToolNameLabel">å·¥å…·åç§°ï¼š</strong><span id="approvalToolName"></span></div>
            <div style="margin-top: 12px;">
              <strong id="approvalToolPurposeLabel">å·¥å…·ç”¨é€”ï¼š</strong>
              <pre id="approvalToolPurpose" style="margin-top: 8px; white-space: pre-wrap; word-wrap: break-word;">è¯¥å·¥å…·å°†ç”¨äºæŠ“å–ç½‘ç»œæ•°æ®ï¼ˆFirecrawlï¼‰ï¼Œå¯èƒ½ä¼šäº§ç”Ÿé¢å¤– API è°ƒç”¨å’Œåˆ†ææ—¶é—´ã€‚</pre>
            </div>
            <div style="margin-top: 12px;"><strong id="approvalToolArgsLabel">å‚æ•°ï¼š</strong><pre id="approvalToolArgs"></pre></div>
          </div>
          <div class="approval-actions">
            <button class="btn-approve" onclick="approveToolCall(true)">âœ“ å…è®¸</button>
            <button class="btn-reject" onclick="approveToolCall(false)">âœ— æ‹’ç»</button>
          </div>
        </div>
      </div>
    </div>

    <div class="footer">
      <div class="footer-text">Powered by AI Â· CompLens Â© 2025</div>
    </div>

    <!-- æŠ¥å‘Šä¸­å¿ƒ / å†å²è®°å½•é¢æ¿ -->
    <div class="history-panel" id="historyPanel">
      <div class="history-header">
        <h3 data-i18n="historyTitle">æŠ¥å‘Šä¸­å¿ƒ Â· å†å²æŸ¥è¯¢</h3>
        <button class="history-close" id="historyClose">Ã—</button>
      </div>
      <div class="history-list" id="historyList"></div>
    </div>

    <button class="history-toggle" id="historyToggle">
      ğŸ“š
      <span class="history-badge" id="historyBadge">0</span>
    </button>

    <button class="history-toggle" id="reportsToggle" style="right: 100px;" title="My Reports">
      ğŸ“Š
    </button>
  </div>

  <script>
  // Intercept fetch responses to capture progress from analyze endpoints
  if (window.fetch && !window._fetchWrappedForProgress) {
    window._fetchWrappedForProgress = true;
    const _origFetch = window.fetch.bind(window);
    window.fetch = async function(input, init) {
      const resp = await _origFetch(input, init);
      try {
        const url = typeof input === 'string' ? input : (input && input.url) || '';
        if (url && (url.endsWith('/api/analyze') || url.endsWith('/api/analyze-file'))) {
          try {
            const clone = resp.clone();
            const data = await clone.json();
            // call handler if exists
            if (window.onServerProgress) window.onServerProgress(data);
          } catch (e) {
            // ignore JSON parse errors
          }
        }
      } catch (e) {
        // ignore
      }
      return resp;
    };
  }

  // Default handler: update latest history item with progress
  window.onServerProgress = function(data){
    try {
      const progress = typeof data.progress === 'number' ? data.progress : undefined;
      const interrupted = !!data.interrupted;
      const sessionId = data.sessionId || data.session_id || data.session || undefined;

      // Try to find a matching history card by sessionId attribute
      let el = null;
      if (sessionId) {
        el = document.querySelector('.history-item[data-session-id="' + sessionId + '"]');
      }
      // fallback: last history item
      if (!el) {
        const list = document.querySelectorAll('.history-item');
        if (list.length) el = list[list.length - 1];
      }
      if (!el) return;

      if (typeof progress === 'number') {
        el.dataset.progress = String(progress);
      }
      el.dataset.interrupted = interrupted ? 'true' : 'false';

      // Update visible UI
      updateHistoryUIElement(el);

    } catch (e) {
      // noop
    }
  };

  // Helper to update a single history element's UI
  function updateHistoryUIElement(el) {
    if (!el) return;
    const interrupted = el.dataset.interrupted === 'true';
    const progress = el.dataset.progress ? parseInt(el.dataset.progress, 10) : undefined;

    // Get current language translations
    const t = translations[currentLang] || translations.zh;

    // Ensure a status container exists
    let status = el.querySelector('.history-status');
    if (!status) {
      status = document.createElement('div');
      status.className = 'history-status';
      // Insert before actions div if it exists, otherwise append
      const actionsDiv = el.querySelector('.history-item-actions');
      if (actionsDiv) {
        el.insertBefore(status, actionsDiv);
      } else {
        el.appendChild(status);
      }
    }

    // Reset classes
    status.className = 'history-status';

    if (interrupted) {
      status.classList.add('interrupted');
      if (progress !== undefined) {
        status.textContent = `${t.statusInterruptedAt} ${progress}%`;
      } else {
        status.textContent = t.statusInterrupted;
      }
    } else {
      // If not interrupted and progress exists, show completed
      if (progress !== undefined) {
        if (progress >= 100) {
          status.classList.add('completed');
          status.textContent = t.statusCompleted;
        } else {
          status.textContent = `${t.statusProgress} ${progress}%`;
        }
      } else {
        status.style.display = 'none';
      }
    }
  }

  // å®¡æ‰¹ç›¸å…³å…¨å±€å˜é‡
    let currentApprovalId = null;
    let currentSessionId = null;
    let currentCheckpointId = null;
    let currentAnalysisParams = null;

    // å¤šè¯­è¨€æ–‡æœ¬é…ç½®
    const i18nTexts = {
      requireToolApprovalLabel: {
        en: 'Require manual approval for Firecrawl calls',
        zh: 'Firecrawl è°ƒç”¨éœ€è¦æ‰‹åŠ¨å®¡æ‰¹',
        ja: 'Firecrawlå‘¼ã³å‡ºã—ã«æ‰‹å‹•æ‰¿èªãŒå¿…è¦'
      },
      requireToolApprovalHelp: {
        en: 'When checked, AI will request your permission before calling Firecrawl tools',
        zh: 'å‹¾é€‰åï¼ŒAI åœ¨è°ƒç”¨ Firecrawl å·¥å…·å‰ä¼šè¯·æ±‚æ‚¨çš„è®¸å¯',
        ja: 'ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã¨ã€AIã¯Firecrawlãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã™å‰ã«è¨±å¯ã‚’æ±‚ã‚ã¾ã™'
      },
      approvalModalTitle: {
        en: 'ğŸ”” Tool Call Approval',
        zh: 'ğŸ”” å·¥å…·è°ƒç”¨å®¡æ‰¹',
        ja: 'ğŸ”” ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã®æ‰¿èª'
      },
      approvalMessage: {
        en: 'AI wants to call the following tool:',
        zh: 'AI æƒ³è¦è°ƒç”¨ä»¥ä¸‹å·¥å…·ï¼š',
        ja: 'AIã¯æ¬¡ã®ãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã—ãŸã„ã¨æ€ã£ã¦ã„ã¾ã™ï¼š'
      },
      approvalToolName: {
        en: 'Tool Name:',
        zh: 'å·¥å…·åç§°ï¼š',
        ja: 'ãƒ„ãƒ¼ãƒ«åï¼š'
      },
      approvalToolArgs: {
        en: 'Parameters:',
        zh: 'å‚æ•°ï¼š',
        ja: 'ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼š'
      },
      approvalToolPurpose: {
        en: 'Tool Purpose:',
        zh: 'å·¥å…·ç”¨é€”ï¼š',
        ja: 'ãƒ„ãƒ¼ãƒ«ã®ç”¨é€”ï¼š'
      },
      approvalToolPurposeText: {
        en: 'This tool will be used to fetch external web data via Firecrawl. It may incur extra API calls and additional processing time.',
        zh: 'è¯¥å·¥å…·å°†ç”¨äºæŠ“å–ç½‘ç»œæ•°æ®ï¼ˆFirecrawlï¼‰ï¼Œå¯èƒ½ä¼šäº§ç”Ÿé¢å¤– API è°ƒç”¨å’Œåˆ†ææ—¶é—´ã€‚',
        ja: 'ã“ã®ãƒ„ãƒ¼ãƒ«ã¯Firecrawlã‚’ä»‹ã—ã¦å¤–éƒ¨Webãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚è¿½åŠ ã®APIå‘¼ã³å‡ºã—ã¨å‡¦ç†æ™‚é–“ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚'
      },
      approveButton: {
        en: 'âœ“ Allow',
        zh: 'âœ“ å…è®¸',
        ja: 'âœ“ è¨±å¯'
      },
      rejectButton: {
        en: 'âœ— Reject',
        zh: 'âœ— æ‹’ç»',
        ja: 'âœ— æ‹’å¦'
      }
    };

    // æ›´æ–°å¤šè¯­è¨€æ–‡æœ¬
    function updateI18nTexts() {
      const lang = currentLang || 'en'; // ä½¿ç”¨å…¨å±€ currentLang å˜é‡
      
      // æ›´æ–°å®¡æ‰¹å¤é€‰æ¡†æ–‡æœ¬
      const labelEl = document.getElementById('requireToolApprovalLabel');
      const helpEl = document.getElementById('requireToolApprovalHelp');
      
      if (labelEl && i18nTexts.requireToolApprovalLabel[lang]) {
        labelEl.textContent = i18nTexts.requireToolApprovalLabel[lang];
      }
      
      if (helpEl && i18nTexts.requireToolApprovalHelp[lang]) {
        helpEl.textContent = i18nTexts.requireToolApprovalHelp[lang];
      }
    }

    // æ›´æ–°å®¡æ‰¹å¼¹çª—æ ‡ç­¾çš„å¤šè¯­è¨€æ”¯æŒ
    function updateApprovalModalLabels() {
      const lang = currentLang || 'en'; // ä½¿ç”¨å…¨å±€ currentLang å˜é‡

      const toolNameLabel = document.getElementById('approvalToolNameLabel');
      const toolArgsLabel = document.getElementById('approvalToolArgsLabel');
      const toolPurposeLabel = document.getElementById('approvalToolPurposeLabel');
      const toolPurpose = document.getElementById('approvalToolPurpose');

      if (toolNameLabel) {
        toolNameLabel.textContent = i18nTexts.approvalToolName[lang] || i18nTexts.approvalToolName.en;
      }

      if (toolArgsLabel) {
        toolArgsLabel.textContent = i18nTexts.approvalToolArgs[lang] || i18nTexts.approvalToolArgs.en;
      }

      if (toolPurposeLabel) {
        toolPurposeLabel.textContent = i18nTexts.approvalToolPurpose[lang] || i18nTexts.approvalToolPurpose.en;
      }

      if (toolPurpose) {
        toolPurpose.textContent = i18nTexts.approvalToolPurposeText[lang] || i18nTexts.approvalToolPurposeText.en;
      }
    }

    // æ˜¾ç¤ºå®¡æ‰¹å¼¹çª—ï¼ˆæ›´æ–°å¤šè¯­è¨€æ”¯æŒï¼‰
    function showApprovalModal(approvalId, toolName, toolArgs, sessionId, checkpointId, analysisParams) {
      currentApprovalId = approvalId;
      currentSessionId = sessionId;
      currentCheckpointId = checkpointId;
      currentAnalysisParams = analysisParams;

      const lang = currentLang || 'en'; // ä½¿ç”¨å…¨å±€ currentLang å˜é‡

      // æ›´æ–°å¼¹çª—æ–‡æœ¬
      const modalTitle = document.querySelector('#approvalModal h3');
      if (modalTitle) {
        modalTitle.textContent = i18nTexts.approvalModalTitle[lang] || i18nTexts.approvalModalTitle.en;
      }

      const modalMessage = document.getElementById('approvalMessage');
      if (modalMessage) {
        modalMessage.textContent = i18nTexts.approvalMessage[lang] || i18nTexts.approvalMessage.en;
      }

      // æ›´æ–°æŒ‰é’®æ–‡æœ¬
      const approveBtn = document.querySelector('.btn-approve');
      const rejectBtn = document.querySelector('.btn-reject');

      if (approveBtn) {
        approveBtn.textContent = i18nTexts.approveButton[lang] || i18nTexts.approveButton.en;
      }

      if (rejectBtn) {
        rejectBtn.textContent = i18nTexts.rejectButton[lang] || i18nTexts.rejectButton.en;
      }

      // æ›´æ–°æ‰€æœ‰æ ‡ç­¾ï¼ˆåŒ…æ‹¬å·¥å…·ç”¨é€”ï¼‰
      updateApprovalModalLabels();

      // å¡«å……å…·ä½“æ•°æ®
      document.getElementById('approvalToolName').textContent = toolName;
      document.getElementById('approvalToolArgs').textContent = JSON.stringify(toolArgs, null, 2);
      document.getElementById('approvalModal').style.display = 'flex';
    }

    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æ‰€æœ‰æ–‡æœ¬
    document.addEventListener('DOMContentLoaded', () => {
      updateI18nTexts();
      updateApprovalModalLabels();
    });

    // å®¡æ‰¹å·¥å…·è°ƒç”¨
    async function approveToolCall(approved) {
      console.log('ğŸ‘† ============================================');
      console.log(`ğŸ‘† User clicked: ${approved ? 'APPROVE âœ…' : 'REJECT âŒ'}`);
      console.log('ğŸ‘† ============================================');
      console.log('   approvalId:', currentApprovalId);
      
      if (!currentApprovalId) {
        console.error('âŒ ERROR: No currentApprovalId!');
        return;
      }

      try {
        console.log('ğŸ“¤ Sending approval decision to backend...');
        
        // å‘é€å®¡æ‰¹å†³å®š
        const response = await fetch('/api/tool-approval', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            approvalId: currentApprovalId,
            approved,
            reason: approved ? 'User approved' : 'User rejected'
          })
        });

        console.log('ğŸ“¥ Response status:', response.status);

        if (!response.ok) {
          throw new Error('Failed to submit approval');
        }

        const data = await response.json();
        console.log('ğŸ“¥ Response data:', data);

        // å…³é—­å¼¹çª—
        document.getElementById('approvalModal').style.display = 'none';
        console.log('âœ… Modal closed');

        if (approved) {
          // ç»§ç»­åˆ†æ
          console.log('âœ… ============================================');
          console.log('âœ… Tool approved, continuing analysis...');
          console.log('âœ… ============================================');
          await continueAnalysisAfterApproval();
        } else {
          // æ‹’ç»ååœæ­¢
          console.log('âŒ ============================================');
          console.log('âŒ Tool rejected, analysis stopped');
          console.log('âŒ ============================================');
          const loadingSection = document.getElementById('loadingSection');
          const inputSection = document.getElementById('inputSection');
          if (loadingSection) loadingSection.classList.remove('visible');
          if (inputSection) inputSection.classList.remove('hidden');
          
          alert(translations[currentLang || 'zh'].errorAnalysis || 'åˆ†æå·²åœæ­¢ï¼šå·¥å…·è°ƒç”¨è¢«æ‹’ç»');
        }
      } catch (error) {
        console.error('âŒ Error submitting approval:', error);
        alert('å®¡æ‰¹å¤±è´¥: ' + error.message);
        const loadingSection = document.getElementById('loadingSection');
        if (loadingSection) loadingSection.classList.remove('visible');
      }
    }

    // å®¡æ‰¹åç»§ç»­åˆ†æ
    async function continueAnalysisAfterApproval() {
      if (!currentAnalysisParams) {
        console.error('âŒ No currentAnalysisParams found!');
        return;
      }

      console.log('ğŸ”„ ============================================');
      console.log('ğŸ”„ CONTINUING ANALYSIS AFTER APPROVAL');
      console.log('ğŸ”„ ============================================');
      console.log('   currentCheckpointId:', currentCheckpointId);
      console.log('   currentSessionId:', currentSessionId);
      console.log('   currentAnalysisParams:', currentAnalysisParams);

      try {
        // Show loading again
        const loadingSection = document.getElementById('loadingSection');
        const loadingText = document.querySelector('.loading-text');
        if (loadingSection && !loadingSection.classList.contains('visible')) {
          loadingSection.classList.add('visible');
        }
        if (loadingText) {
          loadingText.textContent = translations[currentLang || 'zh'].loadingText;
        }

        // ä½¿ç”¨ä¿å­˜çš„ checkpoint ç»§ç»­
        const requestBody = {
          ...currentAnalysisParams,
          checkpointId: currentCheckpointId,
          sessionId: currentSessionId,
        };

        console.log('ğŸ“¤ Sending continue request:', JSON.stringify(requestBody, null, 2));

        const response = await fetch('/api/analyze', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });

        console.log('ğŸ“¥ Response status:', response.status);
        console.log('ğŸ“¥ Response ok:', response.ok);

        const rawText = await response.text();
        console.log('ğŸ“¥ Raw response:', rawText.substring(0, 500));

        let data;
        try {
          data = JSON.parse(rawText);
        } catch (e) {
          console.error('âŒ Failed to parse response as JSON:', e);
          throw new Error('Invalid JSON response: ' + rawText.substring(0, 100));
        }

        console.log('ğŸ“¥ Parsed data:', data);

        if (!response.ok) {
          console.error('âŒ Response not OK');
          throw new Error(data.error || `HTTP ${response.status}: ${rawText.substring(0, 200)}`);
        }

        if (data.needsApproval) {
          // åˆéœ€è¦å®¡æ‰¹
          console.log('ğŸ”” Another tool approval required');
          currentCheckpointId = data.checkpointId;
          showApprovalModal(
            data.approvalId,
            data.toolName,
            data.toolArgs,
            currentSessionId,
            data.checkpointId,
            currentAnalysisParams
          );
        } else {
          // åˆ†æå®Œæˆ
          console.log('âœ… Analysis completed successfully');
          const loadingSection = document.getElementById('loadingSection');
          const reportSection = document.getElementById('reportSection');
          const reportContent = document.getElementById('reportContent');

          if (loadingSection) loadingSection.classList.remove('visible');
          if (reportSection) reportSection.classList.add('visible');
          if (reportContent) {
            reportContent.innerHTML = renderMarkdown(data.report || 'åˆ†æå®Œæˆ');
            reportContent.dataset.fullReport = data.report;
          }

          if (data.interrupted) {
            alert(translations[currentLang || 'zh'].interruptConfirm || 'åˆ†æè¢«ä¸­æ–­ï¼Œä½†å·²ä¿å­˜è¿›åº¦');
          }
        }
      } catch (error) {
        console.error('âŒ ============================================');
        console.error('âŒ ERROR CONTINUING ANALYSIS');
        console.error('âŒ ============================================');
        console.error('Error continuing analysis:', error);
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
        // Alert removed - errors are logged to console instead
        const loadingSection = document.getElementById('loadingSection');
        if (loadingSection) loadingSection.classList.remove('visible');
      }
    }

  // Default language is Chinese
  let currentLang = 'zh';

  // Translations object
  const translations = {
    zh: {
      headerSubtitle: 'AI ç«å“åˆ†æ',
      headerTitle: 'å‘ç°å¡‘é€ ä½ ç«äº‰ä¼˜åŠ¿çš„<em>æ´å¯Ÿ</em>',
      inputLabel: 'è¾“å…¥ä½ çš„äº§å“æƒ³æ³•',
      inputPlaceholder: 'ä¾‹å¦‚ï¼šä¸€ä¸ªå¸®åŠ©ç”¨æˆ·ç®¡ç†ä¸ªäººè´¢åŠ¡çš„ç§»åŠ¨åº”ç”¨ï¼ŒåŒ…å«é¢„ç®—è·Ÿè¸ªã€æŠ•èµ„å»ºè®®å’Œè‡ªåŠ¨åˆ†ç±»åŠŸèƒ½...',
      fileInputLabel: 'æˆ–ä¸Šä¼ æ–‡ä»¶ï¼ˆPDFã€Wordã€TXTã€MDï¼‰',
      fileInputHint: '1ä¸ªæ–‡ä»¶ = åˆ†æï¼Œ2ä¸ªæ–‡ä»¶ = å¯¹æ¯”',
      personaLabel: 'åˆ†æè§†è§’ï¼ˆPersonaï¼‰',
      modelLabel: 'æ¨¡å‹ï¼ˆModelï¼‰',
      webToolsLabel: 'å…è®¸ä½¿ç”¨ Web æŠ“å–ï¼ˆFirecrawl ç­‰é‡å·¥å…·ï¼‰',
      autoContinueLabel: 'å…è®¸è‡ªåŠ¨ç»­å†™é•¿æŠ¥å‘Šï¼ˆMaxTokens è‡ªåŠ¨ç»­å†™ï¼‰',
      quickBtn: 'âš¡ å¿«é€Ÿåé¦ˆ',
      deepBtn: 'ğŸ” æ·±åº¦æŸ¥æ‰¾',
      modeHint: '<strong>å¿«é€Ÿåé¦ˆ</strong>ï¼šé™åˆ¶å·¥å…·è°ƒç”¨ï¼Œ2åˆ†é’Ÿå†…å¿«é€Ÿè¿”å›ç»“æœ<br><strong>æ·±åº¦æŸ¥æ‰¾</strong>ï¼šæ— å·¥å…·é™åˆ¶ï¼Œå…¨é¢æ·±å…¥åˆ†æç«å“',
      loadingText: 'æ­£åœ¨åˆ†æä¸­...',
      loadingSubtext: 'AI æ­£åœ¨æœç´¢å’Œåˆ†æç«å“ä¿¡æ¯',
      reportTitle: 'åˆ†ææŠ¥å‘Š',
      visualizeBtn: 'ğŸ“Š å¯è§†åŒ–',
      backBtn: 'è¿”å›',
      errorEmpty: 'è¯·è¾“å…¥äº§å“æƒ³æ³•ï¼Œæˆ–ä¸Šä¼ ä¸€ä¸ªåŒ…å«äº§å“ä¿¡æ¯çš„æ–‡ä»¶',
      errorNetwork: 'ç½‘ç»œé”™è¯¯ï¼Œè¯·é‡è¯•',
      errorAnalysis: 'åˆ†æå¤±è´¥',
      errorBusy: 'æœåŠ¡å™¨ç¹å¿™ï¼Œè¯·ç¨åé‡è¯•',
      historyTitle: 'æŠ¥å‘Šä¸­å¿ƒ Â· å†å²æŸ¥è¯¢',
      quickMode: 'å¿«é€Ÿ',
      deepMode: 'æ·±åº¦',
      continueBtn: 'ç»§ç»­åˆ†æ',
      viewReportBtn: 'æŸ¥çœ‹æŠ¥å‘Š',
      viewVisualBtn: 'å¯è§†åŒ–',
      visualizeNoJson: 'æŠ¥å‘Šä¸­æœªæ‰¾åˆ° JSON æ•°æ®',
      visualizeError: 'è§£æ JSON æ•°æ®å¤±è´¥',
      interruptBtn: 'â¸ï¸ ä¸­æ–­åˆ†æ',
      interruptConfirm: 'ç¡®å®šè¦ä¸­æ–­å½“å‰åˆ†æå—ï¼Ÿ',
      followUpLabel: 'åŸºäºæœ¬æ¬¡åˆ†æç»§ç»­è¿½é—®ï¼ˆä¾‹å¦‚ï¼šè¯·é‡ç‚¹æ¯”è¾ƒç¾å›½å¸‚åœºæ”¶è´¹æ¨¡å¼ / å†å±•å¼€ 2 ä¸ªå·®å¼‚æœ€å¤§çš„ç«å“ï¼‰',
      followUpPlaceholder: 'è¾“å…¥ä½ æƒ³è¿›ä¸€æ­¥æ·±æŒ–çš„é—®é¢˜æˆ–æ–¹å‘ï¼Œç„¶åç‚¹å‡»ä¸‹é¢æŒ‰é’®ç»§ç»­åˆ†æ',
      followUpBtn: 'â• ç»§ç»­æ²¿ç€è¿™æ¡æ€è·¯åˆ†æ',
      loadingTagInitial: 'é¦–æ¬¡æŸ¥è¯¢',
      loadingTagFollowup: 'è¿½é—®',
      loadingQueryPrefix: 'é—®é¢˜ï¼š',
      loadingFollowupPrefix: 'è¿½é—®ï¼š',
      statusInterrupted: 'â¸ï¸ å·²ä¸­æ–­',
      statusInterruptedAt: 'â¸ï¸ ä¸­æ–­äº',
      statusCompleted: 'âœ“ å·²å®Œæˆ',
      statusProgress: 'è¿›åº¦:',
      waitingApproval: 'â¸ï¸ ç­‰å¾…å·¥å…·è°ƒç”¨å®¡æ‰¹...',
      personaOptions: [
        { value: 'pm',     label: 'äº§å“ç»ç†' },
        { value: 'vc',     label: 'æŠ•èµ„äºº' },
        { value: 'growth', label: 'å¢é•¿ / è¿è¥' },
        { value: 'tech',   label: 'æŠ€æœ¯è´Ÿè´£äºº' },
      ],
      modelOptions: [
        { value: 'deepseek-fast',      label: 'Deepseek - å¿«é€Ÿ / ä¾¿å®œ' },
        { value: 'deepseek-accurate',  label: 'Deepseek - ç²¾å‡† / é«˜è´¨é‡' },
        { value: 'openai-gpt4',        label: 'OpenAI GPT-4ï¼ˆé¢„ç•™ï¼‰' },
        { value: 'anthropic-claude',   label: 'Anthropic Claudeï¼ˆé¢„ç•™ï¼‰' },
      ],
    },
    en: {
      headerSubtitle: 'AI COMPETITIVE ANALYSIS',
      headerTitle: 'Discover <em>insights</em> that shape your competitive edge',
      inputLabel: 'Enter Your Product Idea',
      inputPlaceholder: 'Example: A mobile app for personal finance management with budget tracking, investment advice, and automatic categorization...',
      fileInputLabel: 'Or upload a file (PDF, Word, TXT, MD)',
      fileInputHint: '1 file = analyze, 2 files = compare',
      personaLabel: 'Analysis Persona',
      modelLabel: 'Model',
      webToolsLabel: 'Allow web crawling tools (Firecrawl, etc.)',
      autoContinueLabel: 'Allow automatic continuation for long reports (MaxTokens)',
      quickBtn: 'âš¡ Quick Feedback',
      deepBtn: 'ğŸ” Deep Search',
      modeHint: '<strong>Quick Feedback</strong>: Limited tool calls, fast results within 2 minutes<br><strong>Deep Search</strong>: No tool limits, comprehensive competitor analysis',
      loadingText: 'Analyzing...',
      loadingSubtext: 'AI is searching and analyzing competitor information',
      reportTitle: 'Analysis Report',
      visualizeBtn: 'ğŸ“Š Visualize',
      backBtn: 'Back',
      errorEmpty: 'Please enter a product idea or upload a file.',
      errorNetwork: 'Network error, please try again',
      errorAnalysis: 'Analysis failed',
      errorBusy: 'Server is busy, please try again later',
      historyTitle: 'Report Center Â· History',
      quickMode: 'Quick',
      deepMode: 'Deep',
      continueBtn: 'Continue',
      viewReportBtn: 'View Report',
      viewVisualBtn: 'Visualize',
      visualizeNoJson: 'No JSON data found in the report',
      visualizeError: 'Failed to parse JSON data',
      interruptBtn: 'â¸ï¸ Interrupt Analysis',
      interruptConfirm: 'Are you sure you want to interrupt the current analysis?',
      followUpLabel: 'Ask a follow-up based on this analysis (e.g., focus on US pricing / expand on 2 most different competitors)',
      followUpPlaceholder: 'Type what you want to dig deeper into, then click the button below to continue.',
      followUpBtn: 'â• Continue along this direction',
      loadingTagInitial: 'Initial Query',
      loadingTagFollowup: 'Follow-up',
      loadingQueryPrefix: 'Query: ',
      loadingFollowupPrefix: 'Follow-up: ',
      statusInterrupted: 'â¸ï¸ Interrupted',
      statusInterruptedAt: 'â¸ï¸ Interrupted at',
      statusCompleted: 'âœ“ Completed',
      statusProgress: 'Progress:',
      waitingApproval: 'â¸ï¸ Waiting for tool approval...',
      personaOptions: [
        { value: 'pm',     label: 'Product Manager' },
        { value: 'vc',     label: 'Investor' },
        { value: 'growth', label: 'Growth / Operations' },
        { value: 'tech',   label: 'Tech Lead' },
      ],
      modelOptions: [
        { value: 'deepseek-fast',      label: 'Deepseek - Fast / Cheap' },
        { value: 'deepseek-accurate',  label: 'Deepseek - Accurate / High Quality' },
        { value: 'openai-gpt4',        label: 'OpenAI GPT-4 (reserved)' },
        { value: 'anthropic-claude',   label: 'Anthropic Claude (reserved)' },
      ],
    },
    ja: {
      headerSubtitle: 'AI ç«¶åˆåˆ†æ',
      headerTitle: 'ç«¶äº‰å„ªä½æ€§ã‚’å½¢ä½œã‚‹<em>æ´å¯Ÿ</em>ã‚’ç™ºè¦‹',
      inputLabel: 'è£½å“ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’å…¥åŠ›',
      inputPlaceholder: 'ä¾‹ï¼šäºˆç®—è¿½è·¡ã€æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã€è‡ªå‹•åˆ†é¡æ©Ÿèƒ½ã‚’å‚™ãˆãŸå€‹äººè²¡å‹™ç®¡ç†ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒª...',
      fileInputLabel: 'ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆPDFã€Wordã€TXTã€MDï¼‰',
      fileInputHint: '1ãƒ•ã‚¡ã‚¤ãƒ« = åˆ†æã€2ãƒ•ã‚¡ã‚¤ãƒ« = æ¯”è¼ƒ',
      personaLabel: 'åˆ†æãƒšãƒ«ã‚½ãƒŠ',
      modelLabel: 'ãƒ¢ãƒ‡ãƒ«',
      webToolsLabel: 'Web ã‚¯ãƒ­ãƒ¼ãƒªãƒ³ã‚°ãƒ„ãƒ¼ãƒ«ï¼ˆFirecrawl ãªã©ï¼‰ã‚’è¨±å¯',
      autoContinueLabel: 'é•·ã„ãƒ¬ãƒãƒ¼ãƒˆã®è‡ªå‹•ç¶™ç¶šï¼ˆMaxTokensï¼‰ã‚’è¨±å¯',
      quickBtn: 'âš¡ ã‚¯ã‚¤ãƒƒã‚¯åˆ†æ',
      deepBtn: 'ğŸ” è©³ç´°åˆ†æ',
      modeHint: '<strong>ã‚¯ã‚¤ãƒƒã‚¯åˆ†æ</strong>ï¼šãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã‚’åˆ¶é™ã€2åˆ†ä»¥å†…ã«çµæœã‚’è¿”ã™<br><strong>è©³ç´°åˆ†æ</strong>ï¼šãƒ„ãƒ¼ãƒ«åˆ¶é™ãªã—ã€åŒ…æ‹¬çš„ãªç«¶åˆåˆ†æ',
      loadingText: 'åˆ†æä¸­...',
      loadingSubtext: 'AIãŒç«¶åˆæƒ…å ±ã‚’æ¤œç´¢ãƒ»åˆ†æã—ã¦ã„ã¾ã™',
      reportTitle: 'åˆ†æãƒ¬ãƒãƒ¼ãƒˆ',
      visualizeBtn: 'ğŸ“Š è¦–è¦šåŒ–',
      backBtn: 'æˆ»ã‚‹',
      errorEmpty: 'è£½å“ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’å…¥åŠ›ã™ã‚‹ã‹ã€è£½å“æƒ…å ±ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„',
      errorNetwork: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã€ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„',
      errorAnalysis: 'åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸ',
      errorBusy: 'ã‚µãƒ¼ãƒãƒ¼ãŒæ··é›‘ã—ã¦ã„ã¾ã™ã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„',
      historyTitle: 'ãƒ¬ãƒãƒ¼ãƒˆã‚»ãƒ³ã‚¿ãƒ¼ãƒ»å±¥æ­´',
      quickMode: 'ã‚¯ã‚¤ãƒƒã‚¯',
      deepMode: 'è©³ç´°',
      continueBtn: 'ç¶šã‘ã‚‹',
      viewReportBtn: 'ãƒ¬ãƒãƒ¼ãƒˆ',
      viewVisualBtn: 'è¦–è¦šåŒ–',
      visualizeNoJson: 'ãƒ¬ãƒãƒ¼ãƒˆã« JSON ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“',
      visualizeError: 'JSON ãƒ‡ãƒ¼ã‚¿ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ',
      interruptBtn: 'â¸ï¸ åˆ†æã‚’ä¸­æ–­',
      interruptConfirm: 'ç¾åœ¨ã®åˆ†æã‚’ä¸­æ–­ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ',
      followUpLabel: 'ã“ã®åˆ†æã«åŸºã¥ã„ã¦è¿½è³ªå•ã™ã‚‹ï¼ˆä¾‹ï¼šç±³å›½å¸‚å ´ã®æ–™é‡‘æ¯”è¼ƒ / æœ€ã‚‚ç•°ãªã‚‹ç«¶åˆ2ç¤¾ã‚’è©³ã—ãï¼‰',
      followUpPlaceholder: 'ã•ã‚‰ã«æ·±å €ã‚Šã—ãŸã„å†…å®¹ã‚’å…¥åŠ›ã—ã€ä¸‹ã®ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚',
      followUpBtn: 'â• ã“ã®æ–¹å‘ã§åˆ†æã‚’ç¶šã‘ã‚‹',
      loadingTagInitial: 'åˆå›ã‚¯ã‚¨ãƒª',
      loadingTagFollowup: 'è¿½åŠ è³ªå•',
      loadingQueryPrefix: 'è³ªå•ï¼š',
      loadingFollowupPrefix: 'è¿½åŠ è³ªå•ï¼š',
      statusInterrupted: 'â¸ï¸ ä¸­æ–­',
      statusInterruptedAt: 'â¸ï¸ ä¸­æ–­ï¼š',
      statusCompleted: 'âœ“ å®Œäº†',
      statusProgress: 'é€²æ—:',
      waitingApproval: 'â¸ï¸ ãƒ„ãƒ¼ãƒ«æ‰¿èªå¾…ã¡...',
      personaOptions: [
        { value: 'pm',     label: 'ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼' },
        { value: 'vc',     label: 'æŠ•è³‡å®¶' },
        { value: 'growth', label: 'ã‚°ãƒ­ãƒ¼ã‚¹ / ã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³' },
        { value: 'tech',   label: 'æŠ€è¡“è²¬ä»»è€…' },
      ],
      modelOptions: [
        { value: 'deepseek-fast',      label: 'Deepseek - é«˜é€Ÿ / ä½ã‚³ã‚¹ãƒˆ' },
        { value: 'deepseek-accurate',  label: 'Deepseek - é«˜ç²¾åº¦ / é«˜å“è³ª' },
        { value: 'openai-gpt4',        label: 'OpenAI GPT-4ï¼ˆäºˆç´„ï¼‰' },
        { value: 'anthropic-claude',   label: 'Anthropic Claudeï¼ˆäºˆç´„ï¼‰' },
      ],
    }
  };

  function setLanguage(lang) {
    currentLang = lang;

    document.querySelectorAll('[data-i18n]').forEach(el => {
      const key = el.getAttribute('data-i18n');
      if (translations[lang][key]) {
        if (translations[lang][key].includes('<') && translations[lang][key].includes('>')) {
          el.innerHTML = translations[lang][key];
        } else {
          el.textContent = translations[lang][key];
        }
      }
    });

    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
      const key = el.getAttribute('data-i18n-placeholder');
      if (translations[lang][key]) {
        el.placeholder = translations[lang][key];
      }
    });

    // åŠ¨æ€é‡å»º Persona ä¸‹æ‹‰æ¡†
    const personaSelectEl = document.getElementById('personaSelect');
    if (personaSelectEl && translations[lang].personaOptions) {
      const prevValue = personaSelectEl.value || translations[lang].personaOptions[0]?.value || '';
      personaSelectEl.innerHTML = '';
      translations[lang].personaOptions.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.label;
        personaSelectEl.appendChild(option);
      });
      if ([...personaSelectEl.options].some(o => o.value === prevValue)) {
        personaSelectEl.value = prevValue;
      }
    }

    // åŠ¨æ€é‡å»º Model ä¸‹æ‹‰æ¡†
    const modelSelectEl = document.getElementById('modelSelect');
    if (modelSelectEl && translations[lang].modelOptions) {
      const prevModel = modelSelectEl.value || translations[lang].modelOptions[0]?.value || '';
      modelSelectEl.innerHTML = '';
      translations[lang].modelOptions.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.label;
        modelSelectEl.appendChild(option);
      });
      if ([...modelSelectEl.options].some(o => o.value === prevModel)) {
        modelSelectEl.value = prevModel;
      }
    }

    document.querySelectorAll('.lang-btn').forEach(btn => {
      btn.classList.toggle('active', btn.getAttribute('data-lang') === lang);
    });

    localStorage.setItem('preferredLanguage', lang);
    
    // æ›´æ–°å®¡æ‰¹ç›¸å…³çš„å¤šè¯­è¨€æ–‡æœ¬
    updateI18nTexts();
    updateApprovalModalLabels();
    
    updateHistoryUI(); // è®©å†å²é‡ŒæŒ‰é’®æ–‡æ¡ˆè·Ÿç€è¯­è¨€å˜
  }

  const savedLang = localStorage.getItem('preferredLanguage') || 'zh';
  document.addEventListener('DOMContentLoaded', () => {
    setLanguage(savedLang);
    setSelectedMode('deep'); // åˆå§‹é»˜è®¤é€‰æ·±åº¦æ¨¡å¼
    loadHistory(); // åŠ è½½å†å²è®°å½•
  });

  document.querySelectorAll('.lang-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      setLanguage(btn.getAttribute('data-lang'));
    });
  });

  const ideaInput = document.getElementById('ideaInput');
  const fileInput = document.getElementById('fileInput');
  const quickBtn = document.getElementById('quickBtn');
  const deepBtn = document.getElementById('deepBtn');
  const inputSection = document.getElementById('inputSection');
  const loadingSection = document.getElementById('loadingSection');
  const reportSection = document.getElementById('reportSection');
  const reportContent = document.getElementById('reportContent');
  const backBtn = document.getElementById('backBtn');
  const errorMessage = document.getElementById('errorMessage');
  const interruptBtn = document.getElementById('interruptBtn');
  const personaSelect = document.getElementById('personaSelect');
  const modelSelect = document.getElementById('modelSelect');
  const webToolsToggle = document.getElementById('webToolsToggle');
  const autoContinueToggle = document.getElementById('autoContinueToggle');
  const followUpInput = document.getElementById('followUpInput');
  const followUpBtn = document.getElementById('followUpBtn');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  const loadingTag = document.getElementById('loadingTag');
  const loadingQuery = document.getElementById('loadingQuery');

  let currentAbortController = null;
  let progressInterval = null;
  let lastMode = 'deep'; // è®°å½•æœ€åä½¿ç”¨çš„æ¨¡å¼
  let interruptedThisRun = false; // è®°å½•æœ¬æ¬¡è¿è¡Œæ˜¯å¦è¢«ä¸­æ–­

  // è®¾ç½®é€‰ä¸­çš„åˆ†ææ¨¡å¼ï¼ˆUI åé¦ˆï¼‰
  function setSelectedMode(mode) {
    if (mode === 'quick') {
      quickBtn.classList.add('selected');
      deepBtn.classList.remove('selected');
    } else {
      deepBtn.classList.add('selected');
      quickBtn.classList.remove('selected');
    }
    lastMode = mode;
  }

  function renderMarkdown(text) {
    return text
      .replace(/^### (.*$)/gim, '<h3>$1</h3>')
      .replace(/^## (.*$)/gim, '<h2>$1</h2>')
      .replace(/^# (.*$)/gim, '<h1>$1</h1>')
      .replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>')
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>')
      .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
      .replace(/^\- (.+)$/gim, '<li>$1</li>')
      .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
      .replace(/\n\n/g, '</p><p>')
      .replace(/^(.+)$/gim, '<p>$1</p>')
      .replace(/<p><\/p>/g, '')
      .replace(/<p>(<h[1-3]>)/g, '$1')
      .replace(/(<\/h[1-3]>)<\/p>/g, '$1')
      .replace(/<p>(<ul>)/g, '$1')
      .replace(/(<\/ul>)<\/p>/g, '$1');
  }

  function showError(message) {
    errorMessage.textContent = message;
    errorMessage.classList.add('visible');
    setTimeout(() => {
      errorMessage.classList.remove('visible');
    }, 5000);
  }

  async function runAnalysis(mode, options = {}) {
    const {
      checkpointId = null,
      sessionId = null,
      historyItemId = null,
      followUp = '',
      previousProgress = 0, // æ–°å¢ï¼šå‰ä¸€æ¬¡çš„è¿›åº¦
    } = options;

    // é‡ç½®ä¸­æ–­æ ‡å¿—
    interruptedThisRun = false;

    const idea = ideaInput.value.trim();
    const files = fileInput.files;
    const fileCount = files.length;

    // Validate file count
    if (fileCount > 2) {
      showError(
        currentLang === 'zh'
          ? 'æœ€å¤šåªèƒ½ä¸Šä¼ 2ä¸ªæ–‡ä»¶ï¼ˆ1ä¸ªæ–‡ä»¶=åˆ†æï¼Œ2ä¸ªæ–‡ä»¶=å¯¹æ¯”ï¼‰'
          : currentLang === 'ja'
            ? 'æœ€å¤§2ãƒ•ã‚¡ã‚¤ãƒ«ã¾ã§ï¼ˆ1ãƒ•ã‚¡ã‚¤ãƒ«=åˆ†æã€2ãƒ•ã‚¡ã‚¤ãƒ«=æ¯”è¼ƒï¼‰'
            : 'Maximum 2 files allowed (1 file = analyze, 2 files = compare)'
      );
      return;
    }

    if (!idea && fileCount === 0 && !followUp) {
      showError(translations[currentLang].errorEmpty);
      return;
    }

    console.log(`ğŸ“Š runAnalysis called with:`);
    console.log(`   - mode: ${mode}`);
    console.log(`   - checkpointId: ${checkpointId || 'null'}`);
    console.log(`   - sessionId (arg): ${sessionId || 'null'}`);
    console.log(`   - historyItemId: ${historyItemId || 'null'}`);
    console.log(`   - followUp: ${followUp ? followUp.slice(0, 60) + '...' : 'none'}`);

    let effectiveSessionId = sessionId || currentSessionId;
    if (!effectiveSessionId) {
      effectiveSessionId = Date.now().toString();
    }
    currentSessionId = effectiveSessionId;
    lastMode = mode;

    // Determine what we're analyzing and update loading display
    const t = translations[currentLang];
    let querySource = '';
    const isFollowUp = !!followUp;

    if (followUp) {
      querySource = followUp;
    } else if (idea) {
      querySource = idea;
    } else if (fileCount === 2) {
      // Two files: comparison mode
      querySource = `${files[0].name} vs ${files[1].name}`;
    } else if (fileCount === 1) {
      // Single file: analysis mode
      querySource = files[0].name;
    }

    // Update loading tag and query text
    if (loadingTag && loadingQuery) {
      loadingTag.textContent = isFollowUp ? t.loadingTagFollowup : t.loadingTagInitial;
      loadingTag.classList.toggle('followup', isFollowUp);
      
      const prefix = isFollowUp ? t.loadingFollowupPrefix : t.loadingQueryPrefix;
      loadingQuery.textContent = prefix + (querySource.length > 150 ? querySource.substring(0, 150) + '...' : querySource);
    }

    // remove early runningAnalysis write here (will be moved after persona available)
    inputSection.classList.add('hidden');
    loadingSection.classList.add('visible');
    reportSection.classList.remove('visible');
    quickBtn.disabled = true;
    deepBtn.disabled = true;

    // Reset and start progress animation
    // åªæœ‰åœ¨ç»§ç»­åˆ†æï¼ˆæœ‰ checkpointIdï¼‰æ—¶æ‰ä½¿ç”¨ä¹‹å‰çš„è¿›åº¦
    // åˆå§‹æŸ¥è¯¢å’Œè¿½é—®éƒ½ä» 0% å¼€å§‹ï¼Œé™¤éè°ƒç”¨æ—¶æ˜¾å¼ä¼ å…¥ previousProgress
    const isContinue = !!checkpointId;
    let startProgress = 0;

    // ä¼˜å…ˆä½¿ç”¨è°ƒç”¨å‚æ•° previousProgressï¼ˆæ˜ç¡®ä¼ å…¥æ—¶ä»¥æ­¤ä¸ºå‡†ï¼‰
    if (typeof previousProgress === 'number' && previousProgress > 0) {
      startProgress = Math.min(100, Math.max(0, previousProgress));
      console.log(`ğŸ”„ Resuming from provided previousProgress: ${startProgress}%`);
    } else if (isContinue) {
      // å¦‚æœæ˜¯ç»§ç»­è¯·æ±‚ä½†æ²¡æœ‰ä¼ å…¥ previousProgressï¼Œå°è¯•ä»æœ¬åœ°å†å²é‡Œè¯»å–
      startProgress = 0;
      if (historyItemId) {
        const historyItem = searchHistory.find(item => item.id === historyItemId);
        if (historyItem && typeof historyItem.progress === 'number') {
          startProgress = Math.min(100, Math.max(0, historyItem.progress));
          console.log(`ğŸ”„ Found progress ${startProgress}% from history item ${historyItemId}`);
        }
      }
      console.log(`ğŸ”„ Continuing from ${startProgress}% (isContinue=${isContinue})`);
    } else {
      // æ–°ä»»åŠ¡ï¼šä» 0% å¼€å§‹
      startProgress = 0;
      console.log(`ğŸ†• Starting new analysis from 0%`);
    }

    // Set progress bar immediately to startProgress
    progressBar.style.width = startProgress + '%';
    progressText.textContent = startProgress + '%';

    console.log(`ğŸ“Š Progress bar initialized to ${startProgress}%`);

    // Simulate progress (estimated based on timeout)
    const timeout = mode === 'quick' ? 120000 : 300000; // 2min or 5min
    const startTime = Date.now();
    if (progressInterval) clearInterval(progressInterval);
    progressInterval = setInterval(() => {
      const elapsed = Date.now() - startTime;
      // Calculate progress from startProgress to 95%
      const progressRange = 95 - startProgress;
      const additionalProgress = Math.round((elapsed / timeout) * progressRange);
      const percent = Math.min(95, startProgress + additionalProgress);
      progressBar.style.width = percent + '%';
      progressText.textContent = percent + '%';
    }, 1000);

    currentAbortController = new AbortController();

    const persona = personaSelect.value;
    const model = modelSelect.value;
    const allowWebTools = webToolsToggle.checked;
    const enableAutoContinue = autoContinueToggle.checked;
    const requireToolApproval = document.getElementById('requireToolApproval')?.checked || false;

    // Now persist runningAnalysis with persona included
    const runningAnalysis = {
      idea,
      mode,
      sessionId: effectiveSessionId,
      checkpointId,
      historyItemId,
      followUp,
      persona,
      timestamp: new Date().toISOString()
    };
    localStorage.setItem('runningAnalysis', JSON.stringify(runningAnalysis));

    try {
      console.log(`ğŸŒ runAnalysis â†’ mode=${mode}, checkpointId=${checkpointId || 'null'}`);

      let response;
      if (fileCount > 0 && !followUp) {
        // File upload analysis (single or comparison)
        const formData = new FormData();
        
        // Determine analysis type
        const analysisType = fileCount === 2 ? 'compare' : 'single';
        formData.append('analysisType', analysisType);
        
        // Add files
        if (fileCount === 1) {
          formData.append('file', files[0]);
        } else if (fileCount === 2) {
          formData.append('file1', files[0]);
          formData.append('file2', files[1]);
        }
        
        // Add optional note
        if (idea) {
          formData.append('note', idea);
        }
        
        formData.append('language', currentLang);
        formData.append('mode', mode);
        formData.append('persona', persona);
        formData.append('model', model);
        formData.append('allowWebTools', String(allowWebTools));
        formData.append('enableAutoContinue', String(enableAutoContinue));
        formData.append('requireToolApproval', String(requireToolApproval));
        formData.append('sessionId', effectiveSessionId);
        if (checkpointId) formData.append('checkpointId', checkpointId);

        console.log(`ğŸ“¤ Uploading ${fileCount} file(s) for ${analysisType} analysis`);

        response = await fetch('/api/analyze-file', {
          method: 'POST',
          body: formData,
          signal: currentAbortController.signal
        });
      } else {
        response = await fetch('/api/analyze', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            idea,
            followUp,
            mode,
            language: currentLang,
            persona,
            model,
            allowWebTools,
            enableAutoContinue,
            requireToolApproval,
            checkpointId,
            sessionId: effectiveSessionId,
            previousProgress: startProgress, // å‘é€èµ·å§‹è¿›åº¦ç»™æœåŠ¡å™¨
          }),
          signal: currentAbortController.signal
        });
      }

      let raw;
      try {
        raw = await response.text();
      } catch (e) {
        console.error('Failed to read response body:', e);
        throw new Error(translations[currentLang].errorNetwork);
      }

      let data;
      try {
        data = raw ? JSON.parse(raw) : {};
      } catch (e) {
        console.error('Response is not valid JSON:', raw);
        throw new Error(raw || translations[currentLang].errorAnalysis);
      }

      if (!response.ok) {
        throw new Error(data.error || translations[currentLang].errorAnalysis);
      }

      // Check if approval is needed
      if (data.needsApproval) {
        console.log('ğŸ”” ============================================');
        console.log('ğŸ”” TOOL APPROVAL REQUIRED!');
        console.log('ğŸ”” ============================================');
        console.log('   Approval ID:', data.approvalId);
        console.log('   Tool Name:', data.toolName);
        console.log('   Tool Args:', JSON.stringify(data.toolArgs, null, 2));
        console.log('   Checkpoint ID:', data.checkpointId);
        console.log('   Session ID:', effectiveSessionId);
        console.log('ğŸ”” ============================================');
        
        // Stop progress animation
        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }
        
        // Keep loading visible but update text
        const loadingText = document.querySelector('.loading-text');
        if (loadingText) {
          loadingText.textContent = translations[currentLang].waitingApproval || 'ç­‰å¾…å®¡æ‰¹...';
          console.log('âœ… Updated loading text to "waiting for approval"');
        }
        
        // Save current analysis params for resuming after approval
        currentAnalysisParams = {
          idea,
          followUp,
          mode,
          language: currentLang,
          persona,
          model,
          allowWebTools,
          enableAutoContinue,
          requireToolApproval,
        };
        currentSessionId = effectiveSessionId;
        currentCheckpointId = data.checkpointId;
        
        console.log('ğŸ’¾ Saved analysis params for resuming after approval');
        
        // Show approval modal
        console.log('ğŸ“± Calling showApprovalModal...');
        showApprovalModal(
          data.approvalId,
          data.toolName,
          data.toolArgs,
          effectiveSessionId,
          data.checkpointId,
          currentAnalysisParams
        );
        
        console.log('âœ… Approval modal should now be visible');
        console.log('ğŸ”” Waiting for user decision...');
        
        return; // Don't process as completed report
      }

      let displayReport = data.report;
      const startMarker = "JSON_OUTPUT_START";
      const endMarker = "JSON_OUTPUT_END";
      const start = displayReport.indexOf(startMarker);
      const end = displayReport.indexOf(endMarker);

      if (start !== -1 && end !== -1) {
        displayReport = displayReport.substring(0, start) + displayReport.substring(end + endMarker.length);
      }

      // Clear progress interval and set to 100%
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
      progressBar.style.width = '100%';
      progressText.textContent = '100%';

      loadingSection.classList.remove('visible');
      reportSection.classList.add('visible');
      reportContent.innerHTML = renderMarkdown(displayReport);
      reportContent.dataset.fullReport = data.report;
      delete reportContent.dataset.fromHistory;

      if (followUp) {
        followUpInput.value = '';
      }

      localStorage.removeItem('runningAnalysis');

      const interrupted = data.interrupted || false;
      const newCheckpointId = data.checkpointId || null;

      console.log(`ğŸ’¾ Updating history:`);
      console.log(`   - historyItemId: ${historyItemId || 'null'}`);
      console.log(`   - interrupted: ${interrupted}`);
      console.log(`   - newCheckpointId: ${newCheckpointId || 'null'}`);
      console.log(`   - sessionId (effective): ${effectiveSessionId}`);
      console.log(`   - interruptedThisRun: ${interruptedThisRun}`);

      // å¦‚æœæœ¬æ¬¡è¿è¡Œå·²è¢«ä¸­æ–­ï¼Œä¸è¦è¦†ç›–å†å²è®°å½•
      if (interruptedThisRun) {
        console.log('â¸ï¸ Analysis was interrupted by user, skipping history update');
        return;
      }

      // Build title based on content
      let title;
      if (fileCount === 2) {
        title = `ğŸ“Š ${files[0].name} vs ${files[1].name}`;
      } else if (fileCount === 1) {
        title = `ğŸ“„ ${files[0].name}`;
      } else {
        title = idea || 'Follow-up';
      }
      
      if (followUp) {
        title += ' Â· ' + followUp.slice(0, 40);
      }
      
      const finalProgress = data.progress || (interrupted ? 95 : 100);

      // Determine query type and text
      const queryType = followUp ? 'followup' : 'initial';
      const queryText = followUp || idea || (file && file.name) || '';

      // Extract reportId from response (for file analyses)
      const reportId = data.reportId || null;
      if (reportId) {
        console.log(`ğŸ“‹ Report ID from backend: ${reportId}`);
      }

      if (historyItemId) {
        updateHistory(historyItemId, title, data.report, interrupted, newCheckpointId, effectiveSessionId, persona, finalProgress, queryType, queryText, reportId);
      } else {
        addHistory(title, mode, data.report, interrupted, newCheckpointId, effectiveSessionId, persona, finalProgress, queryType, queryText, reportId);
      }

    } catch (error) {
      console.error('Error:', error);
      
      // Clear progress interval on error
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
      
      loadingSection.classList.remove('visible');
      inputSection.classList.remove('hidden');

      if (error.name === 'AbortError') {
        console.log('Analysis interrupted by user');
      } else {
        showError(error.message || translations[currentLang].errorNetwork);
      }

      const runningAnalysisData = localStorage.getItem('runningAnalysis');
      if (runningAnalysisData) {
        const analysis = JSON.parse(runningAnalysisData);
        const interruptMessage = error.name === 'AbortError'
          ? 'Analysis interrupted by user'
          : (error.message || 'Analysis interrupted');

        const title = (analysis.idea || 'Analysis') + (analysis.followUp ? ' Â· ' + analysis.followUp.slice(0, 40) : '');
        
        // Get current progress from progress bar
        const currentProgress = progressBar ? parseInt(progressBar.style.width) || 0 : 0;
        
        // Determine query type and text
        const queryType = analysis.followUp ? 'followup' : 'initial';
        const queryText = analysis.followUp || analysis.idea || '';

        if (analysis.historyItemId) {
          updateHistory(analysis.historyItemId, title, interruptMessage, true, analysis.checkpointId, analysis.sessionId, analysis.persona, currentProgress, queryType, queryText);
        } else {
          addHistory(title, analysis.mode, interruptMessage, true, analysis.checkpointId, analysis.sessionId, analysis.persona, currentProgress, queryType, queryText);
        }
        localStorage.removeItem('runningAnalysis');
      }
    } finally {
      quickBtn.disabled = false;
      deepBtn.disabled = false;
      currentAbortController = null;
      
      // Clear loading display
      if (loadingTag) loadingTag.classList.remove('followup');
      if (loadingQuery) loadingQuery.textContent = '';
      
      // Ensure progress interval is cleared
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
      
      // Reset currentSearching flag and refresh history UI to show updated item
      if (currentSearching) {
        console.log(`âœ… Analysis finished for item ${currentSearching}, showing in history again`);
        currentSearching = null;
        updateHistoryUI();
      }
    }
  }

  quickBtn.addEventListener('click', () => {
    setSelectedMode('quick');
    currentSessionId = Date.now().toString();
    runAnalysis('quick');
  });

  deepBtn.addEventListener('click', () => {
    setSelectedMode('deep');
    currentSessionId = Date.now().toString();
    runAnalysis('deep');
  });

  // åŸºäºå½“å‰æŠ¥å‘Šçš„è¿½é—®ï¼ˆå¤šè½®å¯¹è¯ï¼‰
  followUpBtn.addEventListener('click', () => {
    const followUp = followUpInput.value.trim();
    if (!followUp) {
      showError(
        currentLang === 'zh'
          ? 'è¯·å…ˆè¾“å…¥ä½ æƒ³è¿½é—®çš„é—®é¢˜æˆ–æ–¹å‘'
          : currentLang === 'ja'
            ? 'è¿½è³ªå•ã®å†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'
            : 'Please type a follow-up question first.'
      );
      return;
    }
    if (!currentSessionId) {
      currentSessionId = Date.now().toString();
    }
    
    // Find the existing history item for this session
    const existingHistoryItem = searchHistory.find(item => item.sessionId === currentSessionId);
    const historyItemId = existingHistoryItem ? existingHistoryItem.id : null;
    
    console.log(`ğŸ“ Follow-up query for session ${currentSessionId}, historyItemId: ${historyItemId || 'new'}`);
    
    runAnalysis(lastMode || 'deep', { 
      followUp, 
      sessionId: currentSessionId,
      historyItemId: historyItemId // Pass existing history item ID to update instead of create
    });
  });

  interruptBtn.addEventListener('click', async () => {
    if (confirm(translations[currentLang].interruptConfirm)) {
      // è®¾ç½®ä¸­æ–­æ ‡å¿—
      interruptedThisRun = true;

      // è·å–å½“å‰è¿›åº¦
      const currentProgress = progressBar ? parseInt(progressBar.style.width) || 0 : 0;

      // å°è¯•å‘åç«¯è¯·æ±‚ä¿å­˜ checkpointï¼ˆå¦‚æœæœ‰ sessionIdï¼‰ä»¥ä¾¿åç»­ç»§ç»­
      let savedCheckpointId = null;
      if (currentSessionId) {
        try {
          const resp = await fetch('/api/save-checkpoint', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ sessionId: currentSessionId })
          });
          if (resp.ok) {
            const data = await resp.json();
            savedCheckpointId = data.checkpointId || null;
            console.log('âœ… Saved checkpoint before abort:', savedCheckpointId);
          } else {
            console.warn('âš ï¸ Failed to save checkpoint before abort');
          }
        } catch (e) {
          console.warn('âš ï¸ Error while saving checkpoint before abort:', e);
        }
      }

      // ç«‹å³ä¿å­˜ä¸­æ–­çŠ¶æ€åˆ°å†å²è®°å½•ï¼ˆä½¿ç”¨åˆšåˆšä¿å­˜çš„ checkpointIdï¼‰
      const runningAnalysisData = localStorage.getItem('runningAnalysis');
      if (runningAnalysisData) {
        try {
          const analysis = JSON.parse(runningAnalysisData);
          const title = (analysis.idea || 'Analysis') + (analysis.followUp ? ' Â· ' + analysis.followUp.slice(0, 40) : '');

          // Determine query type and text
          const queryType = analysis.followUp ? 'followup' : 'initial';
          const queryText = analysis.followUp || analysis.idea || '';

          if (analysis.historyItemId) {
            // æ›´æ–°ç°æœ‰å†å²è®°å½•
            updateHistory(
              analysis.historyItemId,
              title,
              'Analysis interrupted by user',
              true, // interrupted
              savedCheckpointId || analysis.checkpointId || null,
              analysis.sessionId,
              analysis.persona,
              currentProgress,
              queryType,
              queryText
            );
          } else {
            // åˆ›å»ºæ–°çš„å†å²è®°å½•
            addHistory(
              title,
              analysis.mode,
              'Analysis interrupted by user',
              true, // interrupted
              savedCheckpointId || analysis.checkpointId || null,
              analysis.sessionId,
              analysis.persona,
              currentProgress,
              queryType,
              queryText
            );
          }
        } catch (e) {
          console.error('Failed to save interrupted state:', e);
        }
      }

      // ä¸­æ–­è¯·æ±‚
      if (currentAbortController) {
        currentAbortController.abort();
      }

      // æ¸…ç† UI
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }

      loadingSection.classList.remove('visible');
      inputSection.classList.remove('hidden');

      localStorage.removeItem('runningAnalysis');
    }
  });

  backBtn.addEventListener('click', () => {
    reportSection.classList.remove('visible');

    const fromHistory = reportContent.dataset.fromHistory === 'true';

    if (loadingSection.classList.contains('visible')) {
      delete reportContent.dataset.fromHistory;
    } else if (fromHistory) {
      historyPanel.classList.add('open');
      delete reportContent.dataset.fromHistory;
    } else {
      inputSection.classList.remove('hidden');
    }
  });

  const visualizeBtn = document.getElementById('visualizeBtn');
  visualizeBtn.addEventListener('click', () => {
    const fullReport = reportContent.dataset.fullReport;

    if (!fullReport) {
      showError(translations[currentLang].error || 'No report data available');
      return;
    }

    const startMarker = "JSON_OUTPUT_START";
    const endMarker = "JSON_OUTPUT_END";
    const start = fullReport.indexOf(startMarker);
    const end = fullReport.indexOf(endMarker);

    if (start !== -1 && end !== -1) {
      const jsonText = fullReport.slice(start + startMarker.length, end).trim();
      try {
        const data = JSON.parse(jsonText);
        sessionStorage.setItem('visualizationData', JSON.stringify(data));
        sessionStorage.setItem('visualizationLang', currentLang);
        // Use current origin to open visualize page so localStorage/sessionStorage are from the same origin
        window.open(location.origin + '/visualize.html', '_blank');
      } catch (e) {
        console.error('JSON parse error:', e);
        showError(translations[currentLang].error || 'Failed to parse report data for visualization');
      }
    } else {
      console.error('JSON markers not found in report');
      showError(translations[currentLang].error || 'No visualization data found in report');
    }
  });

  ideaInput.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      setSelectedMode('deep');
      currentSessionId = Date.now().toString();
      runAnalysis('deep');
    }
  });

  let searchHistory = [];
  let currentSearching = null;

  const historyPanel = document.getElementById('historyPanel');
  const historyToggle = document.getElementById('historyToggle');
  const historyClose = document.getElementById('historyClose');
  const historyList = document.getElementById('historyList');
  const historyBadge = document.getElementById('historyBadge');

  function loadHistory() {
    const saved = localStorage.getItem('searchHistory');
    if (saved) {
      try {
        searchHistory = JSON.parse(saved);
        updateHistoryUI();
      } catch (e) {
        searchHistory = [];
      }
    }

    const runningAnalysisData = localStorage.getItem('runningAnalysis');
    if (runningAnalysisData) {
      try {
        const analysis = JSON.parse(runningAnalysisData);
        const exists = searchHistory.some(item =>
          item.idea === analysis.idea &&
          item.mode === analysis.mode &&
          Math.abs(new Date(item.timestamp).getTime() - new Date(analysis.timestamp).getTime()) < 60000
        );

        if (!exists) {
          const title = (analysis.idea || 'Analysis') + (analysis.followUp ? ' Â· ' + analysis.followUp.slice(0, 40) : '');
          addHistory(
            title,
            analysis.mode,
            'Analysis interrupted (page reload/close)',
            true,
            analysis.checkpointId,
            analysis.sessionId
          );
        }

        localStorage.removeItem('runningAnalysis');
      } catch (e) {
        console.error('Failed to restore interrupted analysis:', e);
        localStorage.removeItem('runningAnalysis');
      }
    }
  }

  function saveHistory() {
    localStorage.setItem('searchHistory', JSON.stringify(searchHistory.slice(0, 20)));
  }

  function addHistory(title, mode, report, interrupted = false, checkpointId = null, sessionId = null, persona = null, progress = null, queryType = 'initial', queryText = '', reportId = null) {
    const historyItem = {
      id: Date.now() + Math.random(),
      idea: title,
      mode,
      report,
      interrupted,
      checkpointId,
      sessionId,
      persona,
      progress,
      queryType, // 'initial' or 'followup'
      queryText, // the actual query text
      reportId, // backend report ID for file analyses
      timestamp: new Date().toISOString()
    };
    searchHistory.unshift(historyItem);
    saveHistory();
    updateHistoryUI();
  }

  function updateHistory(itemId, title, report, interrupted = false, checkpointId = null, sessionId = null, persona = null, progress = null, queryType = undefined, queryText = undefined, reportId = undefined) {
    const index = searchHistory.findIndex(item => item.id === itemId);
    if (index !== -1) {
      searchHistory[index].idea = title;
      searchHistory[index].report = report;
      searchHistory[index].interrupted = interrupted;
      searchHistory[index].checkpointId = checkpointId;
      searchHistory[index].sessionId = sessionId || searchHistory[index].sessionId;
      // store/update persona if provided
      if (typeof persona !== 'undefined' && persona !== null) {
        searchHistory[index].persona = persona;
      }
      // store/update progress if provided
      if (typeof progress !== 'undefined' && progress !== null) {
        searchHistory[index].progress = progress;
      }
      // store/update queryType if provided
      if (typeof queryType !== 'undefined' && queryType !== null) {
        searchHistory[index].queryType = queryType;
      }
      // store/update queryText if provided
      if (typeof queryText !== 'undefined' && queryText !== null) {
        searchHistory[index].queryText = queryText;
      }
      // store/update reportId if provided
      if (typeof reportId !== 'undefined' && reportId !== null) {
        searchHistory[index].reportId = reportId;
      }
      searchHistory[index].timestamp = new Date().toISOString();
      saveHistory();
      updateHistoryUI();
      console.log(`âœ… Updated history item ${itemId}`);
    } else {
      console.warn(`âš ï¸ History item ${itemId} not found, creating new entry`);
      addHistory(title, searchHistory[0]?.mode || 'deep', report, interrupted, checkpointId, sessionId, persona, progress, queryType, queryText);
    }
  }

  // Helper: map persona value to localized label
  function getPersonaLabel(value) {
    if (!value) return '';
    try {
      const opts = translations[currentLang] && translations[currentLang].personaOptions;
      if (!opts) return value;
      const found = opts.find(function(o){ return o.value === value; });
      return found ? found.label : value;
    } catch (e) { return value; }
  }

  function updateHistoryUI() {
    historyList.innerHTML = '';
    
    // Calculate visible count (exclude currently searching item)
    let visibleCount = 0;

    if (searchHistory.length > 0) {
      historyToggle.classList.add('visible');
    }

    searchHistory.forEach(item => {
      // Skip the item that is currently being resumed
      if (currentSearching && item.id === currentSearching) {
        console.log(`ğŸ”„ Skipping history item ${item.id} - currently analyzing`);
        return;
      }

      // Count visible items
      visibleCount++;

      const div = document.createElement('div');
      div.className = 'history-item';
      // set identifiers for later lookup
      div.setAttribute('data-id', String(item.id));
      if (item.sessionId) div.setAttribute('data-session-id', String(item.sessionId));
      if (item.interrupted) div.setAttribute('data-interrupted', 'true');
      if (item.progress) div.setAttribute('data-progress', String(item.progress));

      const title = document.createElement('div');
      title.className = 'history-item-title';
      title.textContent = item.idea;

      const meta = document.createElement('div');
      meta.className = 'history-item-meta';

      const mode = document.createElement('span');
      mode.className = `history-item-mode ${item.mode}`;
      mode.textContent = translations[currentLang][item.mode === 'quick' ? 'quickMode' : 'deepMode'];

      const personaSpan = document.createElement('span');
      personaSpan.className = 'history-item-persona';
      personaSpan.style.marginLeft = '8px';
      personaSpan.style.fontSize = '11px';
      personaSpan.style.color = '#9ca3af';
      personaSpan.textContent = item.persona ? getPersonaLabel(item.persona) : '';

      const time = document.createElement('span');
      const date = new Date(item.timestamp);
      
      // æ£€æŸ¥æ—¥æœŸæ˜¯å¦æœ‰æ•ˆ
      if (isNaN(date.getTime())) {
        time.textContent = 'Invalid Date';
        console.warn('Invalid timestamp:', item.timestamp);
      } else {
        const locale = currentLang === 'zh' ? 'zh-CN' : currentLang === 'ja' ? 'ja-JP' : 'en-US';
        try {
          time.textContent = date.toLocaleString(locale, {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          });
        } catch (e) {
          // é™çº§å¤„ç†
          time.textContent = date.toLocaleString('en-US', {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          });
        }
      }

      meta.appendChild(mode);
      meta.appendChild(personaSpan);
      meta.appendChild(time);

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'history-item-delete';
      deleteBtn.textContent = 'Ã—';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteHistory(item.id);
      });

      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'history-item-actions';

      if (item.interrupted) {
        const continueBtn = document.createElement('button');
        continueBtn.className = 'history-action-btn primary';
        continueBtn.textContent = translations[currentLang].continueBtn;
        continueBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          continueAnalysis(item);
        });

        actionsDiv.appendChild(continueBtn);
      } else {
        const viewReportBtn = document.createElement('button');
        viewReportBtn.className = 'history-action-btn';
        viewReportBtn.textContent = translations[currentLang].viewReportBtn;
        viewReportBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          viewHistory(item);
        });

        const visualBtn = document.createElement('button');
        visualBtn.className = 'history-action-btn';
        visualBtn.textContent = translations[currentLang].viewVisualBtn;
        visualBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          viewVisualization(item);
        });

        actionsDiv.appendChild(viewReportBtn);
        actionsDiv.appendChild(visualBtn);
      }

      div.appendChild(title);
      div.appendChild(meta);
      div.appendChild(deleteBtn);
      div.appendChild(actionsDiv);

      historyList.appendChild(div);
      
      // ä¸ºæ¯ä¸ªå†å²å¡ç‰‡æ›´æ–°çŠ¶æ€æ˜¾ç¤º
      updateHistoryUIElement(div);
    });
    
    // Update badge with visible count (not total count)
    historyBadge.textContent = visibleCount;
  }

  function viewHistory(item) {
    historyPanel.classList.remove('open');

    let displayReport = item.report;
    const startMarker = "JSON_OUTPUT_START";
    const endMarker = "JSON_OUTPUT_END";
    const start = displayReport.indexOf(startMarker);
    const end = displayReport.indexOf(endMarker);

    if (start !== -1 && end !== -1) {
      displayReport = displayReport.substring(0, start) + displayReport.substring(end + endMarker.length);
    }

    if (!loadingSection.classList.contains('visible')) {
      inputSection.classList.add('hidden');
    }

    reportSection.classList.add('visible');
    reportContent.innerHTML = renderMarkdown(displayReport);
    reportContent.dataset.fullReport = item.report;
    reportContent.dataset.fromHistory = 'true';

    currentSessionId = item.sessionId || currentSessionId;
  }

  function continueAnalysis(item) {
    historyPanel.classList.remove('open');

    // Mark this item as currently being resumed
    currentSearching = item.id;
    console.log(`ğŸ”„ Starting to resume analysis for item ${item.id}`);
    console.log(`   - checkpointId: ${item.checkpointId || 'null'}`);
    console.log(`   - progress: ${item.progress || 0}%`);
    
    // Update UI to hide the item being resumed
    updateHistoryUI();

    currentSessionId = item.sessionId || Date.now().toString();

    inputSection.classList.add('hidden');
    reportSection.classList.remove('visible');
    loadingSection.classList.add('visible');

    // âš ï¸ ä¸è¦åœ¨è¿™é‡Œæ‰‹åŠ¨è®¾ç½®è¿›åº¦æ¡ï¼è®© runAnalysis å¤„ç†
    // å› ä¸º runAnalysis ä¼šæ ¹æ® isContinue å’Œ previousProgress æ­£ç¡®è®¾ç½®

    // Determine if this was a follow-up query
    const followUpText = (item.queryType === 'followup' && item.queryText) ? item.queryText : '';
    
    console.log(`ğŸ”„ Resuming as ${item.queryType} with text: "${followUpText.slice(0, 60)}..."`);

    // âœ… å…³é”®ï¼šç¡®ä¿ä¼ é€’ checkpointId å’Œ previousProgress
    setTimeout(() => {
      runAnalysis(item.mode, {
        checkpointId: item.checkpointId || null, // âœ… å¿…é¡»ä¼ é€’ checkpointId
        sessionId: currentSessionId,
        historyItemId: item.id,
        previousProgress: item.progress || 0,    // âœ… å¿…é¡»ä¼ é€’ previousProgress
        followUp: followUpText,
      });
    }, 100);
  }

  function deleteHistory(itemId) {
    const index = searchHistory.findIndex(item => item.id === itemId);
    if (index !== -1) {
      searchHistory.splice(index, 1);
      saveHistory();
      updateHistoryUI();
    }
  }

  function viewVisualization(item) {
    historyPanel.classList.remove('open');

    const startMarker = "JSON_OUTPUT_START";
    const endMarker = "JSON_OUTPUT_END";
    const start = item.report.indexOf(startMarker);
    const end = item.report.indexOf(endMarker);

    if (start === -1 || end === -1) {
      alert(translations[currentLang].visualizeNoJson || 'No JSON data found in the report');
      return;
    }

    const jsonStr = item.report.substring(start + startMarker.length, end).trim();

    try {
      JSON.parse(jsonStr);

      // Open visualize page using current origin
      const visualizeWindow = window.open(location.origin + '/visualize.html', '_blank');
      visualizeWindow.addEventListener('load', () => {
        visualizeWindow.postMessage({ type: 'visualize', data: jsonStr }, '*');
      });
    } catch (error) {
      console.error('Invalid JSON:', error);
      alert(translations[currentLang].visualizeError || 'Failed to parse JSON data');
    }
  }

  historyToggle.addEventListener('click', () => {
    historyPanel.classList.toggle('open');
  });

  historyClose.addEventListener('click', () => {
    historyPanel.classList.remove('open');
    if (!reportSection.classList.contains('visible') && !loadingSection.classList.contains('visible')) {
      inputSection.classList.remove('hidden');
    }
  });

  document.addEventListener('click', (e) => {
    if (!historyPanel.contains(e.target) && !historyToggle.contains(e.target)) {
      historyPanel.classList.remove('open');
      if (!reportSection.classList.contains('visible') && !loadingSection.classList.contains('visible')) {
        inputSection.classList.remove('hidden');
      }
    }
  });

  // Disable continue buttons when loading
  (function(){
  // Look up the loading section by common IDs/classes used in the app
  const loadingSection = document.getElementById('loadingSection') || document.querySelector('.loading-section') || document.querySelector('#loading-section');
  if (!loadingSection) return; // nothing to do if no loading section present

  // Selectors matching possible 'Continue Analysis' controls in the history list
  const selectors = '[data-action="continue"], .continue-analysis, .continue-btn, button.continue, a.continue, .history-action-btn.primary';

  const getControls = () => Array.from(document.querySelectorAll(selectors));

  function setDisabledState(disabled) {
    for (const el of getControls()) {
      try {
        // Button elements: use the native disabled property
        if (el instanceof HTMLButtonElement || (el.tagName && el.tagName.toUpperCase() === 'BUTTON')) {
          el.disabled = disabled;
        }

        // Links: use ARIA and pointer-events to make them inert
        if ((el instanceof HTMLAnchorElement) || (el.tagName && el.tagName.toUpperCase() === 'A')) {
          if (disabled) {
            el.setAttribute('aria-disabled', 'true');
            el.dataset._disabledByLoading = '1';
            if (el.style) {
              el.style.pointerEvents = 'none';
              el.style.opacity = '0.5';
            }
          } else {
            el.removeAttribute('aria-disabled');
            delete el.dataset._disabledByLoading;
            if (el.style) {
              el.style.pointerEvents = '';
              el.style.opacity = '';
            }
          }
        }

        // Generic fallback for other control types
        if (!(el instanceof HTMLButtonElement) && !(el instanceof HTMLAnchorElement)) {
          if (disabled) {
            el.setAttribute('aria-disabled', 'true');
            if (el.style) {
              el.style.pointerEvents = 'none';
              el.style.opacity = '0.5';
            }
          } else {
            el.removeAttribute('aria-disabled');
            if (el.style) {
              el.style.pointerEvents = '';
              el.style.opacity = '';
            }
          }
        }
      } catch (e) {
        // defensive: ignore any element manipulation errors
      }
    }
  }

  // Prevent click events on matching controls while loading is visible (defensive for custom handlers)
  document.addEventListener('click', function(ev){
    var target = ev.target;
    if (!target || !(target instanceof HTMLElement)) return;
    var control = (typeof target.closest === 'function') ? target.closest(selectors) : null;
    if (!control) return;
    if (loadingSection.classList.contains('visible')) {
      ev.preventDefault();
      ev.stopImmediatePropagation();
      // Optionally you could show a small toast here to explain why it's disabled
    }
  }, true);

  // Observe class changes on the loading section to update controls in real time
  const mo = new MutationObserver(() => {
    const disabled = loadingSection.classList.contains('visible');
    setDisabledState(disabled);
  });
  mo.observe(loadingSection, { attributes: true, attributeFilter: ['class'] });

  // Initialize on DOMContentLoaded and immediately in case script runs after load
  document.addEventListener('DOMContentLoaded', () => setDisabledState(loadingSection.classList.contains('visible')));
  setDisabledState(loadingSection.classList.contains('visible'));
})();
    // æŠ¥å‘Šä¸­å¿ƒæŒ‰é’®
    document.getElementById('reportsToggle')?.addEventListener('click', () => {
      // Use current origin to ensure pages open under same origin (avoid mixing 0.0.0.0 and localhost)
      window.open(location.origin + '/reports.html', '_blank');
    });

    // è®©æŠ¥å‘ŠæŒ‰é’®å§‹ç»ˆå¯è§
    const reportsToggle = document.getElementById('reportsToggle');
    if (reportsToggle) {
      reportsToggle.classList.add('visible');
    }
  </script>

  <style>
    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .checkbox-label input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .help-text {
      display: block;
      margin-top: 4px;
      margin-left: 26px;
      color: #94a3b8;
      font-size: 12px;
    }

    /* Approval Modal Styles */
    .approval-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    .approval-modal-content {
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
      border-radius: 12px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .approval-modal-content h3 {
      margin: 0 0 16px 0;
      color: #f1f5f9;
    }

    .approval-details {
      background: rgba(15, 23, 42, 0.6);
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
      color: #e2e8f0;
    }

    .approval-details div {
      margin: 8px 0;
    }

    .approval-details strong {
      color: #f1f5f9;
    }

    .approval-details pre {
      margin: 8px 0 0 0;
      padding: 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      overflow-x: auto;
      font-size: 12px;
    }

    .approval-actions {
      display: flex;
      gap: 12px;
      margin-top: 20px;
    }

    .btn-approve, .btn-reject {
      flex: 1;
      padding: 12px;
      border-radius: 8px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-approve {
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      color: white;
    }

    .btn-approve:hover {
      background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
      transform: translateY(-2px);
    }

    .btn-reject {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
    }

    .btn-reject:hover {
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
      transform: translateY(-2px);
    }

    /* Button selected state */
    .button.selected {
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
      transform: scale(1.02);
    }

    .button-quick.selected {
      box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.5);
    }

    .button-deep.selected {
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5);
    }

    /* ...existing styles... */
  </style>
</body>
</html>